{------------------------------------------------------------------------------
The contents of this file are subject to the Mozilla Public License
Version 1.1 (the "License"); you may not use this file except in compliance
with the License. You may obtain a copy of the License at
http://www.mozilla.org/MPL/

Software distributed under the License is distributed on an "AS IS" basis,
WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License for
the specific language governing rights and limitations under the License.

The Original Code is: SynHighlighterPas.pas, released 2000-04-17.
The Original Code is based on the mwPasSyn.pas file from the
mwEdit component suite by Martin Waldenburg and other developers, the Initial
Author of this file is Martin Waldenburg.
Portions created by Martin Waldenburg are Copyright (C) 1998 Martin Waldenburg.
Unicode translation by Maël Hörz.
All Rights Reserved.

Contributors to the SynEdit and mwEdit projects are listed in the
Contributors.txt file.

Alternatively, the contents of this file may be used under the terms of the
GNU General Public License Version 2 or later (the "GPL"), in which case
the provisions of the GPL are applicable instead of those above.
If you wish to allow use of your version of this file only under the terms
of the GPL and not to allow others to use your version of this file
under the MPL, indicate your decision by deleting the provisions above and
replace them with the notice and other provisions required by the GPL.
If you do not delete the provisions above, a recipient may use your version
of this file under either the MPL or the GPL.

$Id: SynHighlighterPas.pas,v 1.27.2.10 2009/02/23 15:43:50 maelh Exp $

Known Issues:
-------------------------------------------------------------------------------}
{
@abstract(Resaltado de sintaxis de seudocódigo para SynEdit)
@author(David Abdala)
@created(2025-08-17)
@lastmod(2025-08-17)
}

unit SynHighlighterNuevo;

{$I SynEdit.inc}

interface

uses
  Windows,
  Graphics,
  SynEditTypes,
  SynEditHighlighter,
  SynUnicode,
  SysUtils,
{$IFDEF SYN_CodeFolding}
  SynEditCodeFolding,
  SynRegExpr,
{$ENDIF}
  Classes;

type
  TtkTokenKind = (tkAsm, tkComment, tkIdentifier, tkKey, tkNull, tkNumber,
    tkSpace, tkString, tkSymbol, tkUnknown, tkFloat, tkHex, tkDirec, tkChar,
    tkInner, tkAssignment);

  TRangeState = (rsANil, rsAnsi, rsAnsiAsm, rsAsm, rsBor, rsBorAsm, rsProperty,
    rsExports, rsDirective, rsDirectiveAsm, rsUnknown);

  PIdentFuncTableFunc = ^TIdentFuncTableFunc;
  TIdentFuncTableFunc = function (kw:string): TtkTokenKind of object;

  TProcTableProc = procedure of object;

type
{$IFDEF SYN_CodeFolding}
  TSynSeudoSyn = class(TSynCustomCodeFoldingHighlighter)
{$ELSE}
  TSynSeudoSyn = class(TSynCustomHighlighter)
{$ENDIF}
  private
    FAsmStart: Boolean;
    FRange: TRangeState;
    FIdentFuncTable: array[0..1023] of TIdentFuncTableFunc;
    fProcTable: array[#0..#255] of TProcTableProc;
    FTokenID: TtkTokenKind;
    FStringAttri: TSynHighlighterAttributes;
    FCharAttri: TSynHighlighterAttributes;
    FNumberAttri: TSynHighlighterAttributes;
    FFloatAttri: TSynHighlighterAttributes;
    FHexAttri: TSynHighlighterAttributes;
    FKeyAttri: TSynHighlighterAttributes;
    FSymbolAttri: TSynHighlighterAttributes;
    FAsmAttri: TSynHighlighterAttributes;
    FCommentAttri: TSynHighlighterAttributes;
    FDirecAttri: TSynHighlighterAttributes;
    FIdentifierAttri: TSynHighlighterAttributes;
    FSpaceAttri: TSynHighlighterAttributes;
{$IFDEF SYN_CodeFolding}
    RE_BlockBegin : TRegExpr;
    RE_BlockEnd : TRegExpr;
    RE_Code: TRegExpr;
{$ENDIF}
    function NormalFunc(kw:string): TtkTokenKind;
    function AltFunc(kw:string): TtkTokenKind;
    function HashKey(Str: PWideChar): Cardinal;
    function KeyComp(const aKey: string): Boolean;
    function IdentKind(MayBe: PWideChar): TtkTokenKind;
    procedure MakeMethodTables;
    procedure InitIdent;
    procedure AddressOpProc;
    procedure AsciiCharProc;
    procedure AnsiProc;
    procedure BorProc;
    procedure BraceOpenProc;
    procedure GreaterProc;
    procedure ColonOrGreaterProc;
    procedure CRProc;
    procedure IdentProc;
    procedure IntegerProc;
    procedure LFProc;
    procedure LowerProc;
    procedure NullProc;
    procedure NumberProc;
    procedure PointProc;
    procedure RoundOpenProc;
    procedure SemicolonProc;
    procedure SlashProc;
    procedure SpaceProc;
    procedure StringProc;
    procedure SymbolProc;
    procedure UnknownProc;
  protected
    function GetSampleSource: UnicodeString; override;
    function IsFilterStored: Boolean; override;
//    procedure SetLine(const NewValue: string; LineNumber:Integer); override;
  public
    class function GetLanguageName: string; override;
    class function GetFriendlyLanguageName: UnicodeString; override;
  public
    constructor Create(AOwner: TComponent); override;
    destructor Destroy; override;
    function GetDefaultAttribute(Index: Integer): TSynHighlighterAttributes;
      override;
    function GetEol: Boolean; override;
    function GetRange: Pointer; override;
    function GetTokenAttribute: TSynHighlighterAttributes; override;
    function GetTokenID: TtkTokenKind;
    function GetTokenKind: Integer; override;
    procedure Next; override;
    procedure ResetRange; override;
    procedure SetRange(Value: Pointer); override;
{$IFDEF SYN_CodeFolding}
    procedure ScanForFoldRanges(FoldRanges: TSynFoldRanges;
      LinesToScan: TStrings; FromLine: Integer; ToLine: Integer); override;
    procedure AdjustFoldRanges(FoldRanges: TSynFoldRanges;
      LinesToScan: TStrings); override;
{$ENDIF}
  published
    property AsmAttri: TSynHighlighterAttributes read FAsmAttri write FAsmAttri;
    property CommentAttri: TSynHighlighterAttributes read FCommentAttri
      write FCommentAttri;
    property DirectiveAttri: TSynHighlighterAttributes read FDirecAttri
      write FDirecAttri;
    property IdentifierAttri: TSynHighlighterAttributes read FIdentifierAttri
      write FIdentifierAttri;
    property KeyAttri: TSynHighlighterAttributes read FKeyAttri write FKeyAttri;
    property NumberAttri: TSynHighlighterAttributes read FNumberAttri
      write FNumberAttri;
    property FloatAttri: TSynHighlighterAttributes read FFloatAttri
      write FFloatAttri;
    property HexAttri: TSynHighlighterAttributes read FHexAttri
      write FHexAttri;
    property SpaceAttri: TSynHighlighterAttributes read FSpaceAttri
      write FSpaceAttri;
    property StringAttri: TSynHighlighterAttributes read FStringAttri
      write FStringAttri;
    property CharAttri: TSynHighlighterAttributes read FCharAttri
      write FCharAttri;
    property SymbolAttri: TSynHighlighterAttributes read FSymbolAttri
      write FSymbolAttri;
  end;

procedure Register;

implementation

uses
  SynEditStrConst, langdef;

procedure Register;
begin
// SynEdit highlighters
  RegisterComponents(SYNS_HighlightersPage, [TSynSeudoSyn]);
end;

var
  Identifiers: array[#0..#255] of ByteBool;
  mHashTable: array[#0..#255] of Integer;
  ResWords:array[0..1023] of string;

procedure MakeIdentTable;
var
  I, J: Char;
begin
  for I := #0 to #255 do
  begin
    Case I of
      '_', '0'..'9', 'a'..'z', 'A'..'Z','ñ','Ñ','á','é','í','ó','ú','ü','Á','É','Í','Ó','Ú','Ü': Identifiers[I] := True;
    else Identifiers[I] := False;
    end;
    J := UpCase(I);
    Case I of
      'a'..'z', 'A'..'Z', '_','ñ','Ñ','á','é','í','ó','ú','ü','Á','É','Í','Ó','Ú','Ü': mHashTable[I] := Ord(J) - 64;
    else mHashTable[Char(I)] := 0;
    end;
  end;
end;

{$Q-}
function TSynSeudoSyn.HashKey(Str: PWideChar): Cardinal;
begin
  Result := 0;
  while Str^ in ['_','a'..'z', 'A'..'Z','ñ','Ñ','á','é','í','ó','ú','ü','Á','É','Í','Ó','Ú','Ü'] do
  begin
    inc(Result, mHashTable[Str^]);
    inc(Str);
  end;
  if Str^ in ['0'..'9'] then inc(Str);
  fStringLen := Str - fToIdent;
  if result > 1023 then
    result := 0;
end;
{$Q+}

function TSynSeudoSyn.IdentKind(MayBe: PWideChar): TtkTokenKind;
var
  HKey: Integer;
begin
  fToIdent := MayBe;
  HKey := HashKey(MayBe);
  if HKey > 0 then Result := fIdentFuncTable[HKey](ResWords[HKey]) else
    Result := tkIdentifier;
end;

procedure TSynSeudoSyn.InitIdent;
  procedure SetHashFunc(resWord:string);
  var
    hs:integer;
    tp:char;
  begin
    hs := HashKey(PChar(resWord));
    if resWord = CS_asm then
      tp := 'a'
    else if resWord = CS_end then
      tp := 'e'
    else if resWord = CS_name then
      tp := 'm'
    else if (resWord = CS_read)or(resWord = CS_write)or(resWord = CS_stored)or(resWord = CS_readonly)or(resWord = CS_nodefault)or(resWord = CS_implements)or(resWord = CS_writeonly) then
      tp := 'r'
    else if (resWord = CS_package) or (resWord = CS_contains) or(resWord = CS_requires)then
      tp := 'p'
    else if resWord = CS_index then
      tp := 'i'
    else if resWord = CS_property then
      tp := 'y'
    else if resWord = CS_exports then
      tp := 'x'
    else
      tp := 'n';
    fIdentFuncTable[hs] := NormalFunc;
    ResWords[hs] := ResWords[hs] + ',' + resWord + ',' + tp;
  end;
  procedure SetInnerHash(resWord:string);
  var
    hs:integer;
  begin
    hs := HashKey(PChar(resWord));
    fIdentFuncTable[hs] := NormalFunc;
    ResWords[hs] := ResWords[hs] + ',' + resWord + ',s';
  end;
var
  I: Integer;
  pF: PIdentFuncTableFunc;
begin
  pF := PIdentFuncTableFunc(@fIdentFuncTable);
  for I := Low(fIdentFuncTable) to High(fIdentFuncTable) do begin
    pF^ := AltFunc;
    Inc(pF);
  end;
  SetHashFunc(CS_if);
  SetHashFunc(CS_end);
  SetHashFunc(CS_endFor);
  SetHashFunc(CS_endFunction);
  SetHashFunc(CS_endIf);
  SetHashFunc(CS_endProcedure);
  SetHashFunc(CS_endProgram);
  SetHashFunc(CS_endRecord);
  SetHashFunc(CS_endWhile);
  SetHashFunc(CS_endIterar);
  SetHashFunc(CS_endCase);
  SetHashFunc(CS_endUnit);
  SetHashFunc(CS_caseCase);
  SetHashFunc(CS_do);
  SetHashFunc(CS_and);
  SetHashFunc(CS_as);
  SetHashFunc(CS_of);
  SetHashFunc(CS_in);
  SetHashFunc(CS_far);
  SetHashFunc(CS_Cdecl);
  SetHashFunc(CS_is);
  SetHashFunc(CS_case);
//  SetHashFunc(CS_read); no se utiliza y se usa como procedimiento
  SetHashFunc(CS_on);
  SetHashFunc(CS_label);
  SetHashFunc(CS_mod);
  SetHashFunc(CS_file);
  SetHashFunc(CS_or);
  SetHashFunc(CS_name);
  SetHashFunc(CS_to);
  SetHashFunc(CS_div);
  SetHashFunc(CS_begin);
  SetHashFunc(CS_near);
  SetHashFunc(CS_for);
  SetHashFunc(CS_forFrom);
  SetHashFunc(CS_shl);
  SetHashFunc(CS_packed);
  SetHashFunc(CS_else);
  SetHashFunc(CS_var);
  SetHashFunc(CS_vars);
  SetHashFunc(CS_final);
  SetHashFunc(CS_set);
  SetHashFunc(CS_shr);
  SetHashFunc(CS_sealed);
  SetHashFunc(CS_then);
  SetHashFunc(CS_not);
  SetHashFunc(CS_pascal);
  SetHashFunc(CS_raise);
  SetHashFunc(CS_out);
  SetHashFunc(CS_goto);
  SetHashFunc(CS_while);
  SetHashFunc(CS_xor);
  SetHashFunc(CS_safecall);
  SetHashFunc(CS_with);
  SetHashFunc(CS_dispid);
  SetHashFunc(CS_public);
  SetHashFunc(CS_try);
  SetHashFunc(CS_inline);
  SetHashFunc(CS_unit);
  SetHashFunc(CS_uses);
  SetHashFunc(CS_helper);
  SetHashFunc(CS_repeat);
  SetHashFunc(CS_iterar);
  SetHashFunc(CS_salirSi);
  SetHashFunc(CS_type);
  SetHashFunc(CS_default);
  SetHashFunc(CS_dynamic);
  SetHashFunc(CS_message);
  SetHashFunc(CS_stdcall);
  SetHashFunc(CS_const);
  SetHashFunc(CS_except);
  SetHashFunc(CS_exit);
  SetHashFunc(CS_break);
  SetHashFunc(CS_continue);
  SetHashFunc(CS_until);
  SetHashFunc(CS_finally);
  SetHashFunc(CS_interface);
  SetHashFunc(CS_deprecated);
  SetHashFunc(CS_abstract);
  SetHashFunc(CS_forward);
  SetHashFunc(CS_library);
  SetHashFunc(CS_exports);
  SetHashFunc(CS_program);
//  SetHashFunc(CS_downto);
  SetHashFunc(CS_step);
  SetHashFunc(CS_private);
  SetHashFunc(CS_overload);
  SetHashFunc(CS_inherited);
  SetHashFunc(CS_assembler);
  SetHashFunc(CS_absolute);
  SetHashFunc(CS_published);
  SetHashFunc(CS_override);
  SetHashFunc(CS_threadvar);
  SetHashFunc(CS_export);
  SetHashFunc(CS_external);
  SetHashFunc(CS_automated);
  SetHashFunc(CS_register);
  SetHashFunc(CS_platform);
  SetHashFunc(CS_function);
  SetHashFunc(CS_procedure);
  SetHashFunc(CS_protected);
  SetHashFunc(CS_operator);
  SetHashFunc(CS_implements);
  SetHashFunc(CS_property);
  SetHashFunc(CS_writeonly);
  SetHashFunc(CS_dispinterface);
  SetHashFunc(CS_reintroduce);
  SetHashFunc(CS_finalization);
  SetHashFunc(CS_destructor);
  SetHashFunc(CS_constructor);
  SetHashFunc(CS_implementation);
  SetHashFunc(CS_initialization);
  SetHashFunc(CS_resourcestring);
  SetHashFunc(CS_stringresource);
  //tipos
  SetHashFunc(CS_string);
  SetHashFunc(CS_record);
  SetHashFunc(CS_array);
  SetHashFunc(CS_nil);
  SetHashFunc(CS_class);
  SetHashFunc(CS_object);
  SetHashFunc(CS_integer);
  SetHashFunc(CS_List);
  SetHashFunc(CS_real);
  SetHashFunc(CS_cardinal);
  SetHashFunc(CS_word);
  SetHashFunc(CS_char);
  SetHashFunc(CS_float);
  SetHashFunc(CS_boolean);
  SetHashFunc(CS_currency);
  SetHashFunc(CS_extended);
  SetHashFunc(CS_int64);
  SetHashFunc(CS_longWord);
  SetHashFunc(CS_single);
  SetHashFunc(CS_smallint);
  SetHashFunc(CS_shortint);
  SetHashFunc(CS_TDateTime);
  //funciones y procedimiento internos
  SetInnerHash(CS_charToInt);
  SetInnerHash(CS_intToChar);
  SetInnerHash(CS_delete);
  SetInnerHash(CS_Read);
  SetInnerHash(CS_Show);
  SetInnerHash(CS_Wait);
  SetInnerHash(CS_ClearScreen);
  SetInnerHash(CS_ShowAndRead);
  SetInnerHash(CS_Add);
  SetInnerHash(CS_Random);
  SetInnerHash(CS_ReadDateTime);
  SetInnerHash(CS_Remove);
  SetInnerHash(CS_whatType);
  SetInnerHash(CS_sameType);
  SetInnerHash(CS_sameText);
  SetInnerHash(CS_replace);
  SetInnerHash(CS_copy);
  SetInnerHash(CS_pos);
  SetInnerHash(CS_Item);
  SetInnerHash(CS_AnyToString);
  SetInnerHash(CS_Inc);
  SetInnerHash(CS_Dec);
  SetInnerHash(CS_Count);
  //palabras no reservadas, pero con significado específico
  SetInnerHash(CS_result);
  SetInnerHash(CS_True);
  SetInnerHash(CS_False);

  SetInnerHash(CS_length);
  SetInnerHash(CS_High);
  SetInnerHash(CS_Low);
  SetInnerHash(CS_FormatDateTime);
  SetInnerHash(CS_DateToStr);
  SetInnerHash(CS_Now);
  SetInnerHash(CS_Date);
  SetInnerHash(CS_crlf);
  SetInnerHash(CS_First);
  SetInnerHash(CS_Last);
  SetInnerHash(CS_RemoveLast);
  SetInnerHash(CS_RemoveFirst);
  SetInnerHash(CS_DecodeDate);
  SetInnerHash(CS_EncodeDate);
  SetInnerHash(CS_DecodeTime);
  SetInnerHash(CS_SetLength);
  SetInnerHash(CS_DayOfWeek);
  SetInnerHash(CS_StrToInt);
  SetInnerHash(CS_StrToInt64);
  SetInnerHash(CS_StrToFloat);
  SetInnerHash(CS_StrToDate);
  SetInnerHash(CS_EncodeTime);
  SetInnerHash(CS_Time);
  SetInnerHash(CS_Uppercase);
  SetInnerHash(CS_Lowercase);
  SetInnerHash(CS_Abs);
  SetInnerHash(CS_Trunc);
  SetInnerHash(CS_SizeOf);
  SetInnerHash(CS_Sin);
  SetInnerHash(CS_Trim);
  SetInnerHash(CS_Sqrt);
  SetInnerHash(CS_Pi);
  SetInnerHash(CS_MessageBox);
  SetInnerHash(CS_Int);
  SetInnerHash(CS_TryEncodeDate);
  SetInnerHash(CS_TryEncodeTime);
  {archivos}
  SetInnerHash(CS_OpenFile);
  SetInnerHash(CS_CreateFile);
  SetInnerHash(CS_CloseFile);
  SetInnerHash(CS_WriteFile);
  SetInnerHash(CS_ReadFile);
  SetInnerHash(CS_FileSize);
  SetInnerHash(CS_ValidFile);
  SetInnerHash(CS_EmptyFile);
  SetInnerHash(CS_SeekFile);
  SetInnerHash(CS_FilePos);
end;

function TSynSeudoSyn.AltFunc(kw:string): TtkTokenKind;
begin
  Result := tkIdentifier
end;

constructor TSynSeudoSyn.Create(AOwner: TComponent);
begin
  inherited Create(AOwner);
  FCaseSensitive := False;

  FAsmAttri := TSynHighlighterAttributes.Create(SYNS_AttrAssembler, SYNS_FriendlyAttrAssembler);
  AddAttribute(FAsmAttri);
  FCommentAttri := TSynHighlighterAttributes.Create(SYNS_AttrComment, SYNS_FriendlyAttrComment);
  FCommentAttri.Style:= [fsItalic];
  AddAttribute(FCommentAttri);
  FDirecAttri := TSynHighlighterAttributes.Create(SYNS_AttrPreprocessor, SYNS_FriendlyAttrPreprocessor);
  FDirecAttri.Style:= [fsItalic];
  AddAttribute(FDirecAttri);
  FIdentifierAttri := TSynHighlighterAttributes.Create(SYNS_AttrIdentifier, SYNS_FriendlyAttrIdentifier);
  AddAttribute(FIdentifierAttri);
  FKeyAttri := TSynHighlighterAttributes.Create(SYNS_AttrReservedWord, SYNS_FriendlyAttrReservedWord);
  FKeyAttri.Style:= [fsBold];
  AddAttribute(FKeyAttri);
  FNumberAttri := TSynHighlighterAttributes.Create(SYNS_AttrNumber, SYNS_FriendlyAttrNumber);
  AddAttribute(FNumberAttri);
  FFloatAttri := TSynHighlighterAttributes.Create(SYNS_AttrFloat, SYNS_FriendlyAttrFloat);
  AddAttribute(FFloatAttri);
  FHexAttri := TSynHighlighterAttributes.Create(SYNS_AttrHexadecimal, SYNS_FriendlyAttrHexadecimal);
  AddAttribute(FHexAttri);
  FSpaceAttri := TSynHighlighterAttributes.Create(SYNS_AttrSpace, SYNS_FriendlyAttrSpace);
  AddAttribute(FSpaceAttri);
  FStringAttri := TSynHighlighterAttributes.Create(SYNS_AttrString, SYNS_FriendlyAttrString);
  AddAttribute(FStringAttri);
  FCharAttri := TSynHighlighterAttributes.Create(SYNS_AttrCharacter, SYNS_FriendlyAttrCharacter);
  AddAttribute(FCharAttri);
  FSymbolAttri := TSynHighlighterAttributes.Create(SYNS_AttrSymbol, SYNS_FriendlyAttrSymbol);
  AddAttribute(FSymbolAttri);
  SetAttributesOnChange(DefHighlightChange);

  InitIdent;
  MakeMethodTables;
  FRange := rsUnknown;
  FAsmStart := False;
  FDefaultFilter := SYNS_FilterPascal;

{$IFDEF SYN_CodeFolding}
  RE_BlockBegin := TRegExpr.Create;
  RE_BlockBegin.Expression := '\b(begin|record|class)\b';
  RE_BlockBegin.ModifierI := True;

  RE_BlockEnd := TRegExpr.Create;
  RE_BlockEnd.Expression := '\bend\b';
  RE_BlockEnd.ModifierI := True;

  RE_Code := TRegExpr.Create;
  RE_Code.Expression := '^\s*(function|procedure)\b';
  RE_Code.ModifierI := True;
{$ENDIF}
end;

destructor TSynSeudoSyn.Destroy;
begin 
{$IFDEF SYN_CodeFolding} 
  FreeAndNil(RE_BlockBegin); 
  FreeAndNil(RE_BlockEnd); 
  FreeAndNil(RE_Code); 
{$ENDIF} 
  inherited; 
end; 

procedure TSynSeudoSyn.AddressOpProc;
begin
  FTokenID := tkSymbol;
  Inc(Run);
  if FLine[Run] = '@' then Inc(Run);
end;

procedure TSynSeudoSyn.AsciiCharProc;

  function IsAsciiChar: Boolean;
  begin
    case FLine[Run] of
      '0'..'9', '$', 'A'..'F', 'a'..'f':
        Result := True;
      else
        Result := False;
    end;
  end;
  
begin
  FTokenID := tkChar;
  Inc(Run);
  while IsAsciiChar do
    Inc(Run);
end;

procedure TSynSeudoSyn.BorProc;
begin
  case FLine[Run] of
     #0: NullProc;
    #10: LFProc;
    #13: CRProc;
  else
    begin
      if FRange in [rsDirective, rsDirectiveAsm] then
        FTokenID := tkDirec
      else
        FTokenID := tkComment;
      repeat
        if FLine[Run] = '}' then
        begin
          Inc(Run);
          if FRange in [rsBorAsm, rsDirectiveAsm] then
            FRange := rsAsm
          else
            FRange := rsUnknown;
          Break;
        end;
        Inc(Run);
      until IsLineEnd(Run);
    end;
  end;
end;

procedure TSynSeudoSyn.BraceOpenProc;
begin
  if (FLine[Run + 1] = '$') then
  begin
    if FRange = rsAsm then
      FRange := rsDirectiveAsm
    else
      FRange := rsDirective;
  end
  else
  begin
    if FRange = rsAsm then
      FRange := rsBorAsm
    else
      FRange := rsBor;
  end;
  BorProc;
end;

procedure TSynSeudoSyn.ColonOrGreaterProc;
begin
  FTokenID := tkSymbol;
  Inc(Run);
  if FLine[Run] = '=' then Inc(Run);
end;

procedure TSynSeudoSyn.CRProc;
begin
  FTokenID := tkSpace;
  Inc(Run);
  if FLine[Run] = #10 then
    Inc(Run);
end;

procedure TSynSeudoSyn.IdentProc;
begin
  FTokenID := IdentKind(FLine + Run);
  Inc(Run, FStringLen);
  while IsIdentChar(FLine[Run]) do
    Inc(Run);
end;

procedure TSynSeudoSyn.IntegerProc;

  function IsIntegerChar: Boolean;
  begin
    case FLine[Run] of
      '0'..'9', 'A'..'F', 'a'..'f':
        Result := True;
      else
        Result := False;
    end;
  end;
  
begin
  Inc(Run);
  FTokenID := tkHex;
  while IsIntegerChar do
    Inc(Run);
end;

procedure TSynSeudoSyn.LFProc;
begin
  FTokenID := tkSpace;
  Inc(Run);
end;

procedure TSynSeudoSyn.LowerProc;
begin
  FTokenID := tkSymbol;
  Inc(Run);
  if (FLine[Run] = '=') or (FLine[Run] = '>') then
    Inc(Run);
end;

procedure TSynSeudoSyn.MakeMethodTables;
var
  I: Char;
begin
  for I := #0 to #255 do
    case I of
      CS_CharChar: fProcTable[I] := AsciiCharProc;
      CS_HexChar: fProcTable[I] := IntegerProc;
      CS_quote: fProcTable[I] := StringProc;
      CS_addressOf: fProcTable[I] := AddressOpProc;
      else begin
        case I of
          #0: fProcTable[I] := NullProc;
          #10: fProcTable[I] := LFProc;
          #13: fProcTable[I] := CRProc;
          #1..#9, #11, #12, #14..#32:
            fProcTable[I] := SpaceProc;
          '0'..'9': fProcTable[I] := NumberProc;
          'A'..'Z', 'a'..'z', '_','ñ','Ñ','á','é','í','ó','ú','ü','Á','É','Í','Ó','Ú','Ü':
            fProcTable[I] := IdentProc;
          '{': fProcTable[I] := BraceOpenProc;
          '}', '!', '"', '%', '&', '('..'/', ':'..'@', '['..'^', '`', '~':
            begin
              case I of
                '(': fProcTable[I] := RoundOpenProc;
                '.': fProcTable[I] := PointProc;
                ';': fProcTable[I] := SemicolonProc;
                '/': fProcTable[I] := SlashProc;
                '>': fProcTable[I] := GreaterProc;
                '<': fProcTable[I] := LowerProc;
              else
                fProcTable[I] := SymbolProc;
              end;
            end;
        else
          fProcTable[I] := UnknownProc;
        end;
      end;
    end;
end;

procedure TSynSeudoSyn.NullProc;
begin
  FTokenID := tkNull;
  Inc(Run);
end;

procedure TSynSeudoSyn.NumberProc;

  function IsNumberChar: Boolean;
  begin
    case FLine[Run] of
      '0'..'9', '.', 'e', 'E', '-', '+':
        Result := True;
      else
        Result := False;
    end;
  end;

begin
  Inc(Run);
  FTokenID := tkNumber;
  while IsNumberChar do
  begin
    case FLine[Run] of
      '.':
        if FLine[Run + 1] = '.' then
          Break
        else
          FTokenID := tkFloat;
      'e', 'E': FTokenID := tkFloat;
      '-', '+':
        begin
          if FTokenID <> tkFloat then // arithmetic
            Break;
          if (FLine[Run - 1] <> 'e') and (FLine[Run - 1] <> 'E') then
            Break; //float, but it ends here
        end;
    end;
    Inc(Run);
  end;
end; 

procedure TSynSeudoSyn.PointProc;
begin
  FTokenID := tkSymbol;
  Inc(Run);
  if (FLine[Run] = '.') or (FLine[Run - 1] = ')') then
    Inc(Run);
end; 

procedure TSynSeudoSyn.AnsiProc;
begin
  case FLine[Run] of
     #0: NullProc;
    #10: LFProc;
    #13: CRProc;
  else
    FTokenID := tkComment;
    repeat
      if (FLine[Run] = '*') and (FLine[Run + 1] = ')') then begin
        Inc(Run, 2);
        if FRange = rsAnsiAsm then
          FRange := rsAsm
        else
          FRange := rsUnknown;
        Break;
      end;
      Inc(Run);
    until IsLineEnd(Run);
  end;
end;

procedure TSynSeudoSyn.RoundOpenProc;
begin
  Inc(Run);
  case FLine[Run] of
    '*':
      begin
        Inc(Run);
        if FRange = rsAsm then
          FRange := rsAnsiAsm
        else
          FRange := rsAnsi;
        FTokenID := tkComment;
        if not IsLineEnd(Run) then
          AnsiProc;
      end;
    '.':
      begin
        Inc(Run);
        FTokenID := tkSymbol;
      end;
  else
    FTokenID := tkSymbol;
  end;
end;

procedure TSynSeudoSyn.SemicolonProc;
begin
  Inc(Run);
  FTokenID := tkSymbol;
  if FRange in [rsProperty, rsExports] then
    FRange := rsUnknown;
end;

procedure TSynSeudoSyn.SlashProc;
begin
  Inc(Run);
  if (FLine[Run] = '/') then
  begin
    FTokenID := tkComment;
    repeat
      Inc(Run);
    until IsLineEnd(Run);
  end
  else
    FTokenID := tkSymbol;
end;

procedure TSynSeudoSyn.SpaceProc;
begin
  Inc(Run);
  FTokenID := tkSpace;
  while (FLine[Run] <= #32) and not IsLineEnd(Run) do Inc(Run);
end;

procedure TSynSeudoSyn.StringProc;
begin
  FTokenID := tkString;
  Inc(Run);
  while not IsLineEnd(Run) do
  begin
    if fLine[Run] = CS_quote then begin
      Inc(Run);
      if fLine[Run] <> CS_quote then
        break;
    end;
    Inc(Run);
  end;
end;

procedure TSynSeudoSyn.SymbolProc;
begin
  Inc(Run);
  FTokenID := tkSymbol;
end;

procedure TSynSeudoSyn.UnknownProc;
begin
  Inc(Run);
  FTokenID := tkUnknown;
end;

procedure TSynSeudoSyn.Next;
begin
  FAsmStart := False;
  FTokenPos := Run;
  case FRange of
    rsAnsi, rsAnsiAsm:
      AnsiProc;
    rsBor, rsBorAsm, rsDirective, rsDirectiveAsm:
      BorProc;
    else begin
      if CS_assignment[1] = fLine[Run] then begin
        AssignmentProc;
        if fTokenId <> tkUnknown then
          exit;
      end;
      fProcTable[fLine[Run]];
    end;
  end;
  inherited;
end;

function TSynSeudoSyn.NormalFunc(kw: string): TtkTokenKind;
var
  cpos:integer;
  currw:string;
begin
  Result := tkIdentifier;
  repeat
    Delete(kw,1,1);
    cpos := Pos(',',kw);
    currw := Copy(kw,1,cpos - 1);
    delete(kw,1,cpos);
    if KeyComp(currw) then begin
      Result := tkKey;
      case kw[1] of
        'a':begin
          fRange := rsAsm;
          fAsmStart := True;
        end;
        'e':fRange := rsUnknown;
        'i': if not (fRange in [rsProperty, rsExports]) then Result := tkIdentifier;
        'm': if not (fRange = rsExports) then Result := tkIdentifier;
//        'p': if not PackageSource then Result := tkIdentifier;
        'r': if not (fRange = rsProperty) then Result := tkIdentifier;
        'x': fRange := rsExports;
        'y': fRange := rsProperty;
        's': Result := tkInner;
      end;
      exit;
    end;
    Delete(kw,1,1);
  until kw = '';
end;

function TSynSeudoSyn.GetDefaultAttribute(Index: Integer):
  TSynHighlighterAttributes;
begin
  case Index of
    SYN_ATTR_COMMENT: Result := FCommentAttri;
    SYN_ATTR_IDENTIFIER: Result := FIdentifierAttri;
    SYN_ATTR_KEYWORD: Result := FKeyAttri;
    SYN_ATTR_STRING: Result := FStringAttri;
    SYN_ATTR_WHITESPACE: Result := FSpaceAttri;
    SYN_ATTR_SYMBOL: Result := FSymbolAttri;
  else
    Result := nil;
  end;
end;

function TSynSeudoSyn.GetEol: Boolean;
begin
  Result := Run = FLineLen + 1;
end;

function TSynSeudoSyn.GetTokenID: TtkTokenKind;
begin
  if not FAsmStart and (FRange = rsAsm)
    and not (FTokenID in [tkNull, tkComment, tkDirec, tkSpace])
  then
    Result := tkAsm
  else
    Result := FTokenID;
end;

function TSynSeudoSyn.GetTokenAttribute: TSynHighlighterAttributes;
begin
  case GetTokenID of
    tkAsm: Result := FAsmAttri;
    tkComment: Result := FCommentAttri;
    tkDirec: Result := FDirecAttri;
    tkIdentifier: Result := FIdentifierAttri;
    tkKey: Result := FKeyAttri;
    tkNumber: Result := FNumberAttri;
    tkFloat: Result := FFloatAttri;
    tkHex: Result := FHexAttri;
    tkSpace: Result := FSpaceAttri;
    tkString: Result := FStringAttri;
    tkChar: Result := FCharAttri;
    tkSymbol: Result := FSymbolAttri;
    tkUnknown: Result := FSymbolAttri;
  else
    Result := nil;
  end;
end;

function TSynSeudoSyn.GetTokenKind: Integer;
begin
  Result := Ord(GetTokenID);
end;

procedure TSynSeudoSyn.GreaterProc;
begin
  fTokenID := tkSymbol;
  inc(Run);
  if fLine[Run] = '=' then inc(Run);
end;

function TSynSeudoSyn.GetRange: Pointer;
begin
  Result := Pointer(FRange);
end;

{$IFDEF SYN_CodeFolding}
type
  TRangeStates = set of TRangeState;

Const
  FT_Standard = 1;  // begin end, class end, record end
  FT_Comment = 11;
  FT_Asm = 12;
  FT_HereDocDouble = 13;
  FT_HereDocSingle = 14;
  FT_ConditionalDirective = 15;
  FT_CodeDeclaration = 16;
  FT_CodeDeclarationWithBody = 17;
  FT_Implementation = 18;

procedure TSynSeudoSyn.ScanForFoldRanges(FoldRanges: TSynFoldRanges;
  LinesToScan: TStrings; FromLine, ToLine: Integer);
var
  CurLine: String;
  Line: Integer;

  function BlockDelimiter(Line: Integer): Boolean;
  var
    Index: Integer;
  begin
    Result := False;

    if RE_BlockBegin.Exec(CurLine) then
    begin
      // Char must have proper highlighting (ignore stuff inside comments...)
      Index :=  RE_BlockBegin.MatchPos[0];
      if GetHighlighterAttriAtRowCol(LinesToScan, Line, Index) <> fCommentAttri then
      begin
        // And ignore lines with both opening and closing chars in them
        Re_BlockEnd.InputString := CurLine;
        if not RE_BlockEnd.Exec(Index + 1) then begin
          FoldRanges.StartFoldRange(Line + 1, FT_Standard);
          Result := True;
        end;
      end;
    end else if RE_BlockEnd.Exec(CurLine) then
    begin
      Index := RE_BlockEnd.MatchPos[0];
      if GetHighlighterAttriAtRowCol(LinesToScan, Line, Index) <> fCommentAttri then
      begin
        FoldRanges.StopFoldRange(Line + 1, FT_Standard);
        Result := True;
      end;
    end;
  end;

  function FoldRegion(Line: Integer): Boolean;
  var
    S: string;
  begin
    Result := False;
    S := TrimLeft(CurLine);
    if Uppercase(Copy(S, 1, 8)) = '{$REGION' then
    begin
      FoldRanges.StartFoldRange(Line + 1, FoldRegionType);
      Result := True;
    end
    else if Uppercase(Copy(S, 1, 11)) = '{$ENDREGION' then
    begin
      FoldRanges.StopFoldRange(Line + 1, FoldRegionType);
      Result := True;
    end;
  end;

  function ConditionalDirective(Line: Integer): Boolean;
  var
    S: string;
  begin
    Result := False;
    S := TrimLeft(CurLine);
    if Uppercase(Copy(S, 1, 7)) = '{$IFDEF' then
    begin
      FoldRanges.StartFoldRange(Line + 1, FT_ConditionalDirective);
      Result := True;
    end
    else if Uppercase(Copy(S, 1, 7)) = '{$ENDIF' then
    begin
      FoldRanges.StopFoldRange(Line + 1, FT_ConditionalDirective);
      Result := True;
    end;
  end;

  function IsMultiLineStatement(Line : integer; Ranges: TRangeStates;
     Fold : Boolean; FoldType: Integer = 1): Boolean;
  begin
    Result := True;
    if TRangeState(GetLineRange(LinesToScan, Line)) in Ranges then
    begin
      if Fold and not (TRangeState(GetLineRange(LinesToScan, Line - 1)) in Ranges) then
        FoldRanges.StartFoldRange(Line + 1, FoldType)
      else
        FoldRanges.NoFoldInfo(Line + 1);
    end
    else if Fold and (TRangeState(GetLineRange(LinesToScan, Line - 1)) in Ranges) then
    begin
      FoldRanges.StopFoldRange(Line + 1, FoldType);
    end else
      Result := False;
  end;

begin
  for Line := FromLine to ToLine do
  begin
    // Deal first with Multiline statements
    if IsMultiLineStatement(Line, [rsAnsi], True, FT_Comment) or
       IsMultiLineStatement(Line, [rsAsm, rsAnsiAsm, rsBorAsm, rsDirectiveAsm], True, FT_Asm) or
       IsMultiLineStatement(Line, [rsBor], True, FT_Comment) or
       IsMultiLineStatement(Line, [rsDirective], False)
    then
      Continue;

    CurLine := LinesToScan[Line];

    // Skip empty lines
    if CurLine = '' then begin
      FoldRanges.NoFoldInfo(Line + 1);
      Continue;
    end;

    //  Deal with ConditionalDirectives
    if ConditionalDirective(Line) then
      Continue;

    // Find Fold regions
    if FoldRegion(Line) then
      Continue;

    // Implementation
    if Uppercase(TrimLeft(CurLine)) = 'IMPLEMENTATION' then
      FoldRanges.StartFoldRange(Line +1, FT_Implementation)
    // Functions and procedures
    else if RE_Code.Exec(CurLine) then
      FoldRanges.StartFoldRange(Line + 1, FT_CodeDeclaration)
    // Find begin or end  (Fold Type 1)
    else if not BlockDelimiter(Line) then
      FoldRanges.NoFoldInfo(Line + 1);
  end; //for Line
end;

procedure TSynSeudoSyn.AdjustFoldRanges(FoldRanges: TSynFoldRanges;
      LinesToScan: TStrings);
{
   Provide folding for procedures and functions included nested ones.
}
Var
  i, j, SkipTo: Integer;
  ImplementationIndex: Integer;
  FoldRange: TSynFoldRange;
begin
  ImplementationIndex := - 1;
  for i  := FoldRanges.Ranges.Count - 1 downto 0 do
  begin
    if FoldRanges.Ranges.List[i].FoldType = FT_Implementation then
      ImplementationIndex := i
    else if FoldRanges.Ranges.List[i].FoldType = FT_CodeDeclaration then
    begin
      if ImplementationIndex >= 0 then begin
        // Code declaration in the Interface part of a unit
        FoldRanges.Ranges.Delete(i);
        Dec(ImplementationIndex);
        continue;
      end;
      // Examine the following ranges
      SkipTo := 0;
      j := i + 1;
      while J < FoldRanges.Ranges.Count do begin
        FoldRange := FoldRanges.Ranges.List[j];
        Inc(j);
        case FoldRange.FoldType of
          // Nested procedure or function
          FT_CodeDeclarationWithBody:
            begin
              SkipTo := FoldRange.ToLine;
              continue;
            end;
          FT_Standard:
          // possibly begin end;
            if FoldRange.ToLine <= SkipTo then
              Continue
            else if RE_BlockBegin.Exec(LinesToScan[FoldRange.FromLine - 1]) then
            begin
              if LowerCase(RE_BlockBegin.Match[0]) = 'begin' then
              begin
                // function or procedure followed by begin end block
                // Adjust ToLine
                FoldRanges.Ranges.List[i].ToLine := FoldRange.ToLine;
                FoldRanges.Ranges.List[i].FoldType := FT_CodeDeclarationWithBody;
                break
              end else
              begin
                // class or record declaration follows, so
                FoldRanges.Ranges.Delete(i);
                break;
               end;
            end else
              Assert(False, 'TSynDWSSyn.AdjustFoldRanges');
        else
          begin
            if FoldRange.ToLine <= SkipTo then
              Continue
            else begin
              // Otherwise delete
              // eg. function definitions within a class definition
              FoldRanges.Ranges.Delete(i);
              break
            end;
          end;
        end;
      end;
    end;
  end;
  if ImplementationIndex >= 0 then
    // Looks better without it
    //FoldRanges.Ranges.List[ImplementationIndex].ToLine := LinesToScan.Count;
    FoldRanges.Ranges.Delete(ImplementationIndex);
end;
{$ENDIF}

{procedure TSynSeudoSyn.SetLine(const NewValue: string; LineNumber: Integer);
begin
  fLine := PChar(NewValue);
  Run := 0;
  fLineNumber := LineNumber;
  Next;
end;}

procedure TSynSeudoSyn.SetRange(Value: Pointer);
begin
  FRange := TRangeState(Value);
end;

procedure TSynSeudoSyn.ResetRange;
begin
  FRange:= rsUnknown;
end;

function TSynSeudoSyn.GetSampleSource: UnicodeString;
begin
  Result := '{ Resaltado de sintaxis }'#13#10 +
             'procedimiento TForm1.Button1Click(Sender: TObject)'#13#10 +
             'variables'#13#10 +
             '  Number, I, X: entero'#13#10 +
             'inicio'#13#10 +
             '  Number := 123456'#13#10 +
             '  Caption := "The Number is" + #32 + EnteroACadena(Number)'#13#10 +
             '  para I := 0 hasta Number hacer'#13#10 +
             '  inicio'#13#10 +
             '    Incrementar(X)'#13#10 +
             '    Decrementar(X)'#13#10 +
             '    X <= X + 1.0'#13#10 +
             '    X <= X - $5E'#13#10 +
             '  fin'#13#10 +
             'finprograma';
end;


class function TSynSeudoSyn.GetLanguageName: string;
begin
  Result := SYNS_LangSeudocodigo;
end;

function TSynSeudoSyn.IsFilterStored: Boolean;
begin
  Result := fDefaultFilter <> SYNS_FilterSeudocodigo;
end;


function TSynSeudoSyn.KeyComp(const aKey: string): Boolean;
var
  I: Integer;
  Temp: PChar;
begin
  Temp := fToIdent;
  if Length(aKey) = fStringLen then
  begin
    Result := True;
    for i := 1 to fStringLen do
    begin
      if mHashTable[Temp^] <> mHashTable[aKey[i]] then
      begin
        Result := False;
        break;
      end;
      inc(Temp);
    end;
  end else Result := False;
end;

class function TSynSeudoSyn.GetFriendlyLanguageName: UnicodeString;
begin
  Result := SYNS_FriendlyLangSeudocodigo;
end;

initialization
  MakeIdentTable;
{$IFNDEF SYN_CPPB_1}
  RegisterPlaceableHighlighter(TSynSeudoSyn);
{$ENDIF}
end.

